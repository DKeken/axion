# Правила для работы с типами в Axion Stack

## КРИТИЧЕСКИЕ ПРАВИЛА

### 1. ВСЕГДА используй типы из Protobuf контрактов

**НЕ ДЕЛАЙ:**
- ❌ Хардкод типов в сервисах/контроллерах
- ❌ Локальные type definitions для данных из контрактов
- ❌ Дублирование типов из proto файлов

**ДЕЛАЙ:**
- ✅ Импортируй типы из `@axion/contracts` (они генерируются из proto)
- ✅ Используй `GraphData`, `Node`, `Edge` и другие типы из `@axion/contracts`
- ✅ Если типа нет в contracts - добавь его в proto файл и сгенерируй

### 2. Генерация типов

Все типы генерируются из Protobuf файлов:
```bash
cd packages/contracts
bun run generate
```

Типы экспортируются через `packages/contracts/src/index.ts`:
```typescript
export type { GraphData, Node, Edge } from "../generated/graph/graph";
```

### 3. Использование в коде

```typescript
// ✅ ПРАВИЛЬНО - типы
import { type GraphData, type Node, type Edge } from "@axion/contracts";

// ✅ ПРАВИЛЬНО - enums
import { ServiceStatus, NodeType, EdgeType } from "@axion/contracts";

// ❌ НЕПРАВИЛЬНО - хардкод типов
type GraphData = { nodes: [...], edges: [...] };

// ❌ НЕПРАВИЛЬНО - хардкод enum значений
return "SERVICE_STATUS_PENDING"; // НЕТ! Используй ServiceStatus.SERVICE_STATUS_PENDING
```

### 4. Enums из Protobuf

Все enum значения должны использоваться из Protobuf:
```typescript
// ✅ ПРАВИЛЬНО
import { ServiceStatus } from "@axion/contracts";
return ServiceStatus.SERVICE_STATUS_PENDING;

// ❌ НЕПРАВИЛЬНО
return "SERVICE_STATUS_PENDING";
```

### 5. Проверка перед коммитом

Перед коммитом убедись что:
- Все типы импортируются из `@axion/contracts`
- Все enum значения используются из Protobuf (не строковые литералы)
- Нет локальных определений типов для данных из контрактов
- `bun type-check` проходит успешно

---

## NestJS микросервисы и MessagePattern

### 1. Структура контроллеров

**ДЕЛАЙ:**
```typescript
// ✅ ПРАВИЛЬНО - контроллер делегирует в сервис
@Controller()
export class GraphController {
  private readonly logger = new Logger(GraphController.name);

  constructor(private readonly graphService: GraphService) {}

  @MessagePattern(GRAPH_SERVICE_PATTERNS.CREATE_PROJECT)
  async createProject(@Payload() data: CreateProjectRequest) {
    this.logger.log(`Received ${GRAPH_SERVICE_PATTERNS.CREATE_PROJECT}`);
    return this.graphService.createProject(data);
  }
}
```

**НЕ ДЕЛАЙ:**
- ❌ Бизнес-логика в контроллере
- ❌ Прямая работа с базой данных из контроллера
- ❌ Хардкод MessagePattern строк вместо констант из `@axion/contracts`

### 2. MessagePattern константы

**ДЕЛАЙ:**
```typescript
// ✅ ПРАВИЛЬНО - используй константы из contracts
import { GRAPH_SERVICE_PATTERNS } from "@axion/contracts";

@MessagePattern(GRAPH_SERVICE_PATTERNS.CREATE_PROJECT)
```

**НЕ ДЕЛАЙ:**
```typescript
// ❌ НЕПРАВИЛЬНО - хардкод паттернов
@MessagePattern("graph-service.create-project")
```

### 3. Payload типизация

**ДЕЛАЙ:**
- ✅ Используй **protobuf-сгенерированные Request/Response типы** как DTO для **Kafka и HTTP**.
- ✅ Импортируй типы из `@axion/contracts` (они ре-экспортят `packages/contracts/generated/**`).
- ✅ Если нужного DTO нет — **добавь message в `packages/contracts/proto/**` и сгенерируй** (`bun run generate`).

```typescript
import { type CreateProjectRequest } from "@axion/contracts";

async createProject(@Payload() data: CreateProjectRequest) {
  return this.graphService.createProject(data);
}
```

**НЕ ДЕЛАЙ:**
- ❌ Не описывай payload/request inline объектами в контроллерах/сервисах
- ❌ Не создавай локальные `type { ... }`/`interface { ... }` для DTO

### 4. Логирование в контроллерах

Всегда логируй входящие запросы:
```typescript
this.logger.log(`Received ${GRAPH_SERVICE_PATTERNS.CREATE_PROJECT}`);
```

---

## Структура сервисов и бизнес-логика

### 1. Разделение ответственности

**ДЕЛАЙ:**
- ✅ Main Service (координатор) - делегирует вызовы специализированным сервисам
- ✅ Специализированные сервисы (ProjectsService, GraphOperationsService и т.д.)
- ✅ Repository - только работа с БД
- ✅ Helpers - переиспользуемая логика

**НЕ ДЕЛАЙ:**
- ❌ Вся логика в одном сервисе
- ❌ Бизнес-логика в Repository
- ❌ Прямые SQL запросы в сервисах

### 2. Структура модуля

```typescript
@Module({
  controllers: [GraphController],
  providers: [
    // Main coordinator
    GraphService,
    // Specialized services
    ProjectsService,
    GraphOperationsService,
    // Repositories
    ProjectRepository,
    GraphRepository,
  ],
})
export class GraphModule {}
```

### 3. Dependency Injection

**ДЕЛАЙ:**
```typescript
@Injectable()
export class ProjectsService {
  constructor(private readonly projectRepository: ProjectRepository) {}
}
```

**НЕ ДЕЛАЙ:**
- ❌ Создание инстансов через `new`
- ❌ Импорт db напрямую в сервисы (используй Repository)

---

## Работа с базой данных (Drizzle ORM)

### 1. Repository Pattern

**ДЕЛАЙ:**
```typescript
@Injectable()
export class ProjectRepository {
  async create(data: CreateProject): Promise<Project> {
    const [project] = await db.insert(projects).values(data).returning();
    return project;
  }

  async findById(id: string): Promise<Project | null> {
    const [project] = await db
      .select()
      .from(projects)
      .where(eq(projects.id, id))
      .limit(1);
    return project || null;
  }
}
```

**НЕ ДЕЛАЙ:**
- ❌ Прямые запросы к `db` из сервисов
- ❌ Бизнес-логика в Repository
- ❌ Типы из Drizzle напрямую (используй типы из schema)

### 2. Database Connection

**ДЕЛАЙ:**
```typescript
// Используй shared utility
import { createDatabaseConnection } from "@axion/database";
import * as schema from "./schema";

const { client, db } = createDatabaseConnection(connectionString, schema);
export { client, db };
```

### 3. Schema и типы

**ДЕЛАЙ:**
```typescript
// В schema.ts
export const projects = pgTable("projects", {
  id: uuid("id").primaryKey().defaultRandom(),
  // ...
});

export type Project = typeof projects.$inferSelect;
export type CreateProject = typeof projects.$inferInsert;
export type UpdateProject = Partial<CreateProject>;
```

### 4. Обновление записей

**ДЕЛАЙ:**
```typescript
async update(id: string, data: UpdateProject): Promise<Project | null> {
  const [updated] = await db
    .update(projects)
    .set({
      ...data,
      [projects.updatedAt.name]: sql`now()`, // ✅ Автоматическое обновление updated_at
    })
    .where(eq(projects.id, id))
    .returning();
  return updated || null;
}
```

### 5. Пагинация

**ДЕЛАЙ:**
```typescript
async findByUserId(
  userId: string,
  page: number = 1,
  limit: number = 10
): Promise<{ projects: Project[]; total: number }> {
  const offset = (page - 1) * limit;
  const allProjects = await db
    .select()
    .from(projects)
    .where(eq(projects.userId, userId));
  
  const total = allProjects.length;
  const paginated = allProjects.slice(offset, offset + limit);
  
  return { projects: paginated, total };
}
```

---

## Обработка ошибок и ответов

### 1. Единая система обработки ошибок

**ДЕЛАЙ:**
```typescript
import { handleServiceError } from "@axion/shared";
import {
  createSuccessResponse,
  createErrorResponse,
  createNotFoundError,
  createValidationError,
} from "@axion/contracts";

// Базовое использование
try {
  const project = await this.repository.create(data);
  return createSuccessResponse(project);
} catch (error) {
  return handleServiceError(this.logger, "creating project", error);
}

// С контекстом для лучшего логирования
catch (error) {
  return handleServiceError(this.logger, "getting project", error, {
    resourceType: "Project",
    resourceId: id,
    userId: context.userId,
  });
}
```

**Что делает handleServiceError:**
- ✅ Автоматически классифицирует ошибки (Database, Validation, NotFound, etc.)
- ✅ Правильно логирует с нужным уровнем (warn для validation, error для internal)
- ✅ Конвертирует в Protobuf-compatible формат
- ✅ Обрабатывает PostgreSQL/Drizzle ошибки автоматически

**НЕ ДЕЛАЙ:**
- ❌ НЕ обрабатывай ошибки вручную - пусть система их классифицирует
- ❌ НЕ используй try-catch без handleServiceError
- ❌ НЕ создавай свои error classes - используй существующие из @axion/shared
- ❌ НЕ логируй ошибки вручную - handleServiceError делает это автоматически

### 2. Response utilities

**ДЕЛАЙ:**
```typescript
// Успешный ответ - отправляй данные напрямую
return createSuccessResponse(project);
return createSuccessResponse({ projects, pagination });

// Ошибка валидации
return createErrorResponse(createValidationError("field is required", "field"));

// Ошибка not found
return createErrorResponse(createNotFoundError("Project", projectId));
```

**НЕ ДЕЛАЙ:**
- ❌ Прямое создание объектов ответа
- ❌ Строковые литералы для кодов ошибок
- ❌ **НЕ ДЕЛАЙ лишний маппинг данных** - отправляй данные из repository напрямую
- ❌ НЕ используй `.map()` для преобразования данных перед отправкой
- ❌ НЕ преобразуй поля вручную (например, `createdAt.getTime()`) - отправляй объекты как есть

### 3. Валидация входных данных

**ДЕЛАЙ:**
```typescript
import { getUserIdFromMetadata } from "@axion/contracts";

const userId = getUserIdFromMetadata(data.metadata);
if (!userId) {
  return createErrorResponse(
    createValidationError("user_id is required in metadata")
  );
}
```

### 4. Проверка существования ресурсов

**ДЕЛАЙ:**
```typescript
const project = await this.repository.findById(projectId);
if (!project) {
  return createErrorResponse(
    createNotFoundError("Project", projectId)
  );
}
```

---

## Безопасность и доступ

### 1. Project Access Verification

**ДЕЛАЙ:**
```typescript
import { verifyProjectAccess } from "@/graph/helpers/project-access.helper";

const access = await verifyProjectAccess(
  this.projectRepository,
  projectId,
  metadata
);
if (!access.success) return access.response;
```

**НЕ ДЕЛАЙ:**
- ❌ Пропуск проверки доступа к проекту
- ❌ Прямая проверка без использования helper

### 2. Metadata extraction

**ДЕЛАЙ:**
```typescript
import { getUserIdFromMetadata } from "@axion/contracts";

const userId = getUserIdFromMetadata(data.metadata);
```

**НЕ ДЕЛАЙ:**
```typescript
// ❌ Прямой доступ к metadata без проверки
const userId = (data.metadata as any).user_id;
```

---

## Логирование

### 1. Logger в сервисах

**ДЕЛАЙ:**
```typescript
@Injectable()
export class ProjectsService {
  private readonly logger = new Logger(ProjectsService.name);

  async create(data: CreateProjectRequest) {
    this.logger.log("Creating project");
    // ...
  }
}
```

### 2. Логирование ошибок

**ДЕЛАЙ:**
```typescript
// Используй handleServiceError - он логирует автоматически
catch (error) {
  return handleServiceError(this.logger, "creating project", error);
}
```

**НЕ ДЕЛАЙ:**
- ❌ console.log/console.error
- ❌ Логирование без контекста

---

## Структура файлов и папок

### 1. Структура модуля NestJS

```
src/
├── {module}/
│   ├── {module}.module.ts      # Module definition
│   ├── {module}.controller.ts  # MessagePattern handlers
│   ├── {module}.service.ts     # Main coordinator service
│   ├── services/               # Specialized services
│   │   ├── {feature}.service.ts
│   ├── repositories/           # Database repositories
│   │   ├── {entity}.repository.ts
│   ├── helpers/                # Reusable helpers
│   │   ├── {helper}.helper.ts
│   └── dto/                    # DTOs (если нужны)
│       ├── {dto}.dto.ts
├── database/
│   ├── schema.ts               # Drizzle schema
│   ├── connection.ts           # DB connection
│   └── index.ts
└── main.ts
```

### 2. Naming conventions

- **Файлы:** kebab-case (`project.repository.ts`)
- **Классы:** PascalCase (`ProjectRepository`)
- **Переменные/функции:** camelCase (`createProject`)
- **Константы:** UPPER_SNAKE_CASE (`GRAPH_SERVICE_PATTERNS`)
- **Таблицы БД:** snake_case (`project_graph_versions`)

---

## Миграции базы данных

### 1. Генерация миграций

**ДЕЛАЙ:**
```bash
cd apps/graph-service
bun run migrate:generate  # Генерирует миграции из schema
```

### 2. Применение миграций

```bash
bun run migrate          # Применяет миграции
bun run migrate:push     # Push schema (dev only)
```

### 3. Schema changes

**ДЕЛАЙ:**
- ✅ Изменяй schema.ts
- ✅ Генерируй миграцию через `migrate:generate`
- ✅ Проверяй сгенерированный SQL
- ✅ Применяй миграцию

**НЕ ДЕЛАЙ:**
- ❌ Прямые изменения в БД без миграций
- ❌ Ручное редактирование SQL миграций (кроме крайних случаев)

---

## Monorepo и зависимости

### 1. Использование workspace packages

**ДЕЛАЙ:**
```typescript
import { GraphData } from "@axion/contracts";
import { handleServiceError } from "@axion/shared";
import { createDatabaseConnection } from "@axion/database";
```

### 2. Package.json dependencies

**ДЕЛАЙ:**
```json
{
  "dependencies": {
    "@axion/contracts": "workspace:*",
    "@axion/shared": "workspace:*",
    "@axion/database": "workspace:*"
  }
}
```

### 3. Не дублируй код между пакетами

**ДЕЛАЙ:**
- ✅ Общую логику в `@axion/shared`
- ✅ Контракты и типы в `@axion/contracts`
- ✅ Database utilities в `@axion/database`

**НЕ ДЕЛАЙ:**
- ❌ Дублирование helper функций
- ❌ Локальные копии типов из contracts

---

## TypeScript и типизация

### 1. Strict typing

**ДЕЛАЙ:**
```typescript
// ✅ Явная типизация возвращаемых значений
async findById(id: string): Promise<Project | null> {
  // ...
}

// ✅ Type guards для проверки типов
if (isSuccessResponse(response)) {
  const data = response.result.data;
}
```

### 2. Использование type imports

**ДЕЛАЙ:**
```typescript
import { type GraphData, type Node } from "@axion/contracts";
import { type ProjectRepository } from "@/graph/repositories/project.repository";
```

### 3. Типы из Drizzle schema

**ДЕЛАЙ:**
```typescript
import {
  type Project,
  type CreateProject,
  type UpdateProject,
} from "@/database/schema";
```

### 4. Запрет динамических импортов

**НЕ ДЕЛАЙ:**
```typescript
// ❌ Динамические импорты для обхода проблем с инициализацией модулей
const { client } = await import("@/database/connection");
const module = await import("@/some/module");
```

**ДЕЛАЙ:**
```typescript
// ✅ Обычные статические импорты на уровне модуля
import { client } from "@/database/connection";
import { SomeModule } from "@/some/module";

// ✅ Если нужно обработать ошибку подключения - делай это в try-catch при использовании
try {
  await client`SELECT 1`;
} catch (error) {
  // Обработка ошибки
}
```

**Почему:**
- Динамические импорты усложняют код и скрывают проблемы с инициализацией
- Статические импорты позволяют TypeScript и bundler'ам правильно анализировать зависимости
- Ошибки инициализации должны быть явными и обрабатываться на уровне модуля, а не скрываться через динамические импорты

---

## Тестирование (будущее)

### 1. Unit tests

- Тестируй бизнес-логику в сервисах
- Мокай Repository
- Используй тестовые утилиты из `@axion/shared` (когда будут)

### 2. Integration tests

- Тестируй MessagePattern handlers
- Используй test database
- Проверяй полный flow от контроллера до БД

---

## Better Auth и аутентификация

### 1. Использование Better Auth

**ДЕЛАЙ:**
```typescript
// ✅ Серверная сторона (NestJS)
import { AxionAuthModule } from "@axion/better-auth/nestjs";
import { createBetterAuth } from "@axion/better-auth";

// ✅ Клиентская сторона (React/Next.js)
import { SignInForm, UserButton } from "@axion/better-auth/ui";
import { useSession } from "better-auth/react";
```

### 2. TypeScript Path Aliases

**КРИТИЧЕСКИ ВАЖНО:** Всегда используй path aliases вместо относительных путей (`../`, `../../`).

**ДЕЛАЙ:**
```typescript
// ✅ Использование aliases
import { Button } from "@/components/button";
import { useAuth } from "@/hooks/use-auth";
import { authClient } from "@/lib/auth-client";
import { db } from "@/database";
import { ProjectRepository } from "@/graph/repositories/project.repository";
import { verifyProjectAccess } from "@/graph/helpers/project-access.helper";
```

**НЕ ДЕЛАЙ:**
```typescript
// ❌ Относительные пути - ЗАПРЕЩЕНО
import { Button } from "../../components/button";
import { db } from "../../database";
import { ProjectRepository } from "../repositories/project.repository";
import { verifyProjectAccess } from "../helpers/project-access.helper";
```

### 3. Available Aliases

Базовые aliases настроены в `typescript-config`:
- `@/*` - корень src/app (или src/ для сервисов)
- `@/components/*` - компоненты
- `@/lib/*` - библиотеки/утилиты
- `@/utils/*` - утилиты
- `@/hooks/*` - React hooks
- `@/types/*` - TypeScript типы
- `@/config/*` - конфигурации
- `@/graph/*` - модули graph (для graph-service)
- `@/database/*` - database модули
- `@/health/*` - health модули

**Для NestJS сервисов:**
- `@/database` → `src/database`
- `@/graph/repositories` → `src/graph/repositories`
- `@/graph/services` → `src/graph/services`
- `@/graph/helpers` → `src/graph/helpers`

---

---

## Connect-RPC и ProtoValidate - Валидация и Типобезопасность

### 1. Установка и конфигурация

**Необходимые пакеты:**
```json
{
  "dependencies": {
    "@connectrpc/connect": "^1.x",
    "@connectrpc/connect-node": "^1.x",
    "@connectrpc/protoc-gen-connect-es": "^1.x",
    "@bufbuild/protobuf": "^1.x",
    "@bufbuild/protovalidate": "^1.x",
    "@bufbuild/buf": "^1.x"
  }
}
```

**Конфигурация buf.gen.yaml:**
```yaml
version: v2
plugins:
  - remote: buf.build/protocolbuffers/es
    out: generated
    opt:
      - target=ts
  - remote: buf.build/connectrpc/es
    out: generated
    opt:
      - target=ts
```

### 2. Валидация в Proto файлах

**ВСЕГДА добавляй валидацию в proto файлах:**

```protobuf
syntax = "proto3";

package axion.graph.v1;

import "buf/validate/validate.proto";

message CreateProjectRequest {
  RequestMetadata metadata = 1 [(buf.validate.field).required = true];
  
  string name = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 255
  ];
  
  string description = 3 [
    (buf.validate.field).string.max_len = 1000
  ];
  
  string user_id = 4 [
    (buf.validate.field).string.uuid = true
  ];
  
  option (buf.validate.message).cel = {
    id: "name_not_empty"
    message: "name must not be empty or whitespace only"
    expression: "this.name.trim().size() > 0"
  };
}

message User {
  string id = 1 [(buf.validate.field).string.uuid = true];
  uint32 age = 2 [(buf.validate.field).uint32.lte = 150];
  string email = 3 [(buf.validate.field).string.email = true];
  string first_name = 4 [(buf.validate.field).string.max_len = 64];
  string last_name = 5 [(buf.validate.field).string.max_len = 64];
  
  option (buf.validate.message).cel = {
    id: "first_name_requires_last_name"
    message: "last_name must be present if first_name is present"
    expression: "!has(this.first_name) || has(this.last_name)"
  };
}
```

**Стандартные валидации buf.validate:**
- `string.min_len` / `string.max_len` - длина строки
- `string.uuid` - валидация UUID
- `string.email` - валидация email
- `string.pattern` - regex паттерн (RE2 синтаксис)
- `uint32.gte` / `uint32.lte` - границы чисел
- `repeated.min_items` / `repeated.max_items` - размер массива
- `required = true` - обязательное поле
- Custom CEL expressions для сложной логики

### 3. Валидация в NestJS сервисах

**ВСЕГДА валидируй входящие данные через @bufbuild/protovalidate:**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { createValidator } from "@bufbuild/protovalidate";
import { 
  CreateProjectRequest,
  CreateProjectRequestSchema,
  type CreateProjectResponse 
} from "@axion/contracts";
import { 
  createSuccessResponse,
  createErrorResponse,
  createValidationError 
} from "@axion/contracts";

@Injectable()
export class ProjectsService {
  private readonly logger = new Logger(ProjectsService.name);
  private readonly validator = createValidator();

  async create(data: CreateProjectRequest): Promise<CreateProjectResponse> {
    // ✅ Валидация через protovalidate
    const validationResult = this.validator.validate(
      CreateProjectRequestSchema,
      data
    );
    
    if (validationResult.kind !== "valid") {
      this.logger.warn("Validation failed", {
        violations: validationResult.violations,
      });
      
      const firstViolation = validationResult.violations[0];
      return createErrorResponse(
        createValidationError(
          firstViolation.message,
          firstViolation.fieldPath
        )
      );
    }

    // Бизнес-логика после успешной валидации
    try {
      const project = await this.projectRepository.create({
        name: data.name,
        description: data.description,
        userId: data.userId,
      });
      
      return createSuccessResponse(project);
    } catch (error) {
      return handleServiceError(this.logger, "creating project", error);
    }
  }
}
```

### 4. Валидация в контроллерах

**Для Kafka/MessagePattern:**

```typescript
import { Controller, UseGuards, Logger } from "@nestjs/common";
import { Payload } from "@nestjs/microservices";
import { createValidator } from "@bufbuild/protovalidate";
import { 
  GRAPH_SERVICE_PATTERNS,
  CreateProjectRequest,
  CreateProjectRequestSchema,
  type CreateProjectResponse 
} from "@axion/contracts";
import { 
  MessagePatternWithLog,
  MicroserviceAuthGuard 
} from "@axion/nestjs-common";

@Controller()
@UseGuards(MicroserviceAuthGuard)
export class GraphController {
  private readonly logger = new Logger(GraphController.name);
  private readonly validator = createValidator();

  constructor(private readonly graphService: GraphService) {}

  @MessagePatternWithLog(GRAPH_SERVICE_PATTERNS.CREATE_PROJECT)
  async createProject(
    @Payload() data: CreateProjectRequest
  ): Promise<CreateProjectResponse> {
    // ✅ Валидация на уровне контроллера
    const validationResult = this.validator.validate(
      CreateProjectRequestSchema,
      data
    );
    
    if (validationResult.kind !== "valid") {
      this.logger.warn("Invalid request received", {
        pattern: GRAPH_SERVICE_PATTERNS.CREATE_PROJECT,
        violations: validationResult.violations,
      });
      
      return createErrorResponse(
        createValidationError(
          validationResult.violations[0].message,
          validationResult.violations[0].fieldPath
        )
      );
    }

    return this.graphService.createProject(data);
  }
}
```

**Для HTTP/REST:**

```typescript
import { Controller, Post, Body, UseGuards } from "@nestjs/common";
import { createValidator } from "@bufbuild/protovalidate";
import { 
  CreateProjectRequest,
  CreateProjectRequestSchema,
  type CreateProjectResponse,
  type RequestMetadata 
} from "@axion/contracts";
import { 
  AxionRequestMetadata,
  HttpAuthGuard 
} from "@axion/nestjs-common";

@Controller("api/projects")
@UseGuards(HttpAuthGuard)
export class GraphHttpController {
  private readonly validator = createValidator();

  constructor(private readonly graphService: GraphService) {}

  @Post()
  async createProject(
    @AxionRequestMetadata() metadata: RequestMetadata,
    @Body() body: Omit<CreateProjectRequest, "metadata">
  ): Promise<CreateProjectResponse> {
    const request: CreateProjectRequest = { metadata, ...body };
    
    // ✅ Валидация перед передачей в сервис
    const validationResult = this.validator.validate(
      CreateProjectRequestSchema,
      request
    );
    
    if (validationResult.kind !== "valid") {
      return createErrorResponse(
        createValidationError(
          validationResult.violations[0].message,
          validationResult.violations[0].fieldPath
        )
      );
    }

    return this.graphService.createProject(request);
  }
}
```

### 5. Connect-RPC сервисы

**Используй Connect-RPC для type-safe RPC:**

```typescript
import { ConnectRouter } from "@connectrpc/connect";
import { createValidator } from "@bufbuild/protovalidate";
import type { 
  CreateProjectRequest,
  CreateProjectRequestSchema 
} from "@axion/contracts";

export function graphServiceRouter(router: ConnectRouter) {
  const validator = createValidator();

  router.rpc(GraphService, "createProject", async (req: CreateProjectRequest) => {
    // ✅ Автоматическая валидация через protovalidate
    const validationResult = validator.validate(
      CreateProjectRequestSchema,
      req
    );
    
    if (validationResult.kind !== "valid") {
      throw new ConnectError(
        validationResult.violations[0].message,
        Code.InvalidArgument
      );
    }

    // Бизнес-логика
    return await projectService.create(req);
  });
}
```

### 6. Обработка ошибок валидации

**ВСЕГДА обрабатывай все нарушения валидации:**

```typescript
import { createValidator } from "@bufbuild/protovalidate";
import type { Violation } from "@bufbuild/protovalidate";

@Injectable()
export class ValidationService {
  private readonly validator = createValidator();

  validate<T>(schema: any, data: T): { success: true } | { success: false; errors: string[] } {
    const result = this.validator.validate(schema, data);
    
    if (result.kind === "valid") {
      return { success: true };
    }

    // ✅ Собираем все ошибки валидации
    const errors = result.violations.map((v: Violation) => 
      `${v.fieldPath}: ${v.message}`
    );
    
    return { success: false, errors };
  }
}
```

### 7. Custom CEL валидации

**Используй CEL для сложной бизнес-логики:**

```protobuf
message UpdateProjectRequest {
  string project_id = 1 [(buf.validate.field).string.uuid = true];
  string name = 2;
  ProjectStatus status = 3;
  
  option (buf.validate.message).cel = {
    id: "status_transition_valid"
    message: "Cannot transition from ARCHIVED to ACTIVE directly"
    expression: "!(this.status == ProjectStatus.ACTIVE && oldStatus == ProjectStatus.ARCHIVED)"
  };
  
  option (buf.validate.message).cel = {
    id: "name_changed_requires_reason"
    message: "Name changes require a reason to be provided"
    expression: "this.name == oldName || has(this.change_reason)"
  };
}
```

### 8. Вынос общих Helper-ов

**Создай переиспользуемые валидаторы:**

```typescript
// packages/shared/src/validation/protovalidate.helper.ts
import { createValidator } from "@bufbuild/protovalidate";
import type { Logger } from "@nestjs/common";
import { 
  createErrorResponse,
  createValidationError,
  type ServiceResponse 
} from "@axion/contracts";

export class ProtoValidator {
  private readonly validator = createValidator();

  validateOrError<T>(
    schema: any,
    data: T,
    logger?: Logger
  ): ServiceResponse | null {
    const result = this.validator.validate(schema, data);
    
    if (result.kind === "valid") {
      return null; // No error
    }

    if (logger) {
      logger.warn("Validation failed", {
        violations: result.violations.map(v => ({
          field: v.fieldPath,
          message: v.message,
        })),
      });
    }

    const firstViolation = result.violations[0];
    return createErrorResponse(
      createValidationError(firstViolation.message, firstViolation.fieldPath)
    );
  }
}
```

**Использование:**

```typescript
import { ProtoValidator } from "@axion/shared";
import { CreateProjectRequestSchema } from "@axion/contracts";

@Injectable()
export class ProjectsService {
  private readonly protoValidator = new ProtoValidator();

  async create(data: CreateProjectRequest): Promise<CreateProjectResponse> {
    // ✅ Переиспользуемый валидатор
    const error = this.protoValidator.validateOrError(
      CreateProjectRequestSchema,
      data,
      this.logger
    );
    if (error) return error as CreateProjectResponse;

    // Бизнес-логика...
  }
}
```

### 9. Contracts-First Approach

**Любые DTO/структуры — только типы из `@axion/contracts` (protobuf):**

```typescript
// ✅ ПРАВИЛЬНО - типы и схемы из contracts
import { 
  type CreateProjectRequest,
  type CreateProjectResponse,
  CreateProjectRequestSchema,
  type Project 
} from "@axion/contracts";

async createProject(data: CreateProjectRequest): Promise<CreateProjectResponse> {
  // ...
}

// ❌ НЕПРАВИЛЬНО - локальные типы для данных из контрактов
type CreateProjectRequest = { // ❌ НЕТ!
  name: string;
  description?: string;
};
```

**Если типа нет:**
1. Добавь `message` в `packages/contracts/proto/**/*.proto`
2. Добавь валидацию через `buf.validate` annotations
3. Сгенерируй: `cd packages/contracts && bun run generate`
4. Импортируй типы и схемы из `@axion/contracts`

**НЕ ДЕЛАЙ:**
- ❌ НЕ используй class-validator/class-transformer
- ❌ НЕ создавай DTO классы с декораторами
- ❌ НЕ дублируй валидацию в коде - используй proto annotations
- ❌ НЕ используй Typia/Nestia - только ProtoValidate

## Чеклист перед коммитом

- [ ] Все типы импортируются из `@axion/contracts`
- [ ] Все enum значения используются из Protobuf
- [ ] Нет хардкода MessagePattern - используются константы
- [ ] Все ошибки обрабатываются через `handleServiceError`
- [ ] Все ответы через `createSuccessResponse` / `createErrorResponse`
- [ ] Проверка доступа к проекту через `verifyProjectAccess`
- [ ] Логирование через Logger (не console)
- [ ] Repository pattern используется для работы с БД
- [ ] Использование path aliases вместо относительных путей
- [ ] Нет дублирования кода между пакетами
- [ ] Нет циклических зависимостей
- [ ] Нет лишнего маппинга данных - отправляй данные из repository напрямую
- [ ] Все proto файлы содержат `buf.validate` аннотации для валидации
- [ ] Валидация через `@bufbuild/protovalidate` в контроллерах и сервисах
- [ ] Используются схемы из `@axion/contracts` (`*Schema`) для валидации
- [ ] Нет class-validator/class-transformer - только ProtoValidate
- [ ] Нет Typia/Nestia - только Connect-RPC и ProtoValidate
- [ ] Используются helpers из `@axion/nestjs-common` (normalizePagination, toNumberOrUndefined и т.д.)
- [ ] `bun type-check` проходит успешно
- [ ] `bun lint` проходит успешно
