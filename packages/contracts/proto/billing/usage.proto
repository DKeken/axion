syntax = "proto3";

package axion.billing;

import "common/common.proto";

// Usage tracking messages
message TrackUsageRequest {
  axion.common.RequestMetadata metadata = 1;
  string user_id = 2;
  UsageMetric metric = 3;
}

message UsageMetric {
  axion.common.UsageMetricType metric_type = 1;
  double value = 2;
  map<string, string> metadata = 3; // Дополнительная информация (например, модель LLM)
  int64 timestamp = 4;
}

message GetUsageRequest {
  axion.common.RequestMetadata metadata = 1;
  string user_id = 2;
  optional axion.common.UsageMetricType metric_type = 3; // Опционально: фильтр по типу метрики
  int64 start_date = 4; // Unix timestamp
  int64 end_date = 5; // Unix timestamp
}

message Usage {
  string user_id = 1;
  axion.common.UsageMetricType metric_type = 2;
  double total_value = 3;
  double current_period_value = 4;
  int64 last_updated = 5;
}

message UsageResponse {
  axion.common.Status status = 1;
  oneof result {
    axion.common.Error error = 2;
    UsageData data = 3;
  }
}

message UsageData {
  repeated Usage usages = 1;
  int64 period_start = 2;
  int64 period_end = 3;
}

message CheckLimitsRequest {
  axion.common.RequestMetadata metadata = 1;
  string user_id = 2;
  repeated LimitCheck checks = 3;
}

message LimitCheck {
  axion.common.LimitType limit_type = 1;
  double current_value = 2;
  double requested_increment = 3; // На сколько нужно увеличить (для проверки можно ли добавить)
}

message CheckLimitsResponse {
  axion.common.Status status = 1;
  oneof result {
    axion.common.Error error = 2;
    LimitCheckResult data = 3;
  }
}

message LimitCheckResult {
  repeated LimitStatus limits = 1;
  bool all_within_limits = 2;
}

message LimitStatus {
  axion.common.LimitType limit_type = 1;
  double current_value = 2;
  double limit_value = 3;
  bool within_limit = 4;
  optional string error_message = 5;
}
