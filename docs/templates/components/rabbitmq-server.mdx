---
title: "Component: RabbitMQ Server"
description: "Сервер для обработки RabbitMQ сообщений. Регистрирует handlers и обрабатывает входящие сообщения."
order: 6
---

# Component: RabbitMQ Server

## Описание

Сервер для обработки RabbitMQ сообщений. Регистрирует handlers и обрабатывает входящие сообщения.

**Используется в:** всех сервисах с RabbitMQ

## Конфигурация

- `{VHOST}` - виртуальный хост RabbitMQ (обычно `project_{PROJECT_ID}`)

## Код

```typescript
// src/messaging/server.ts
import amqp from "amqplib";

export class RabbitMQServer {
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;
  private handlers: Map<string, Function> = new Map();

  constructor(
    private config: {
      url: string;
      vhost: string;
    }
  ) {}

  async connect() {
    try {
      this.connection = await amqp.connect(
        `${this.config.url}/${this.config.vhost}`
      );
      this.channel = await this.connection.createChannel();
      console.log(`Connected to RabbitMQ vhost: ${this.config.vhost}`);
    } catch (error) {
      console.error("Failed to connect to RabbitMQ:", error);
      throw error;
    }
  }

  registerHandler(pattern: string, handler: Function) {
    this.handlers.set(pattern, handler);
    console.log(`Registered handler: ${pattern}`);
  }

  async start() {
    if (!this.connection) {
      await this.connect();
    }

    if (!this.channel) {
      throw new Error("Channel not initialized");
    }

    // Регистрируем все handlers
    for (const [pattern, handler] of this.handlers) {
      const queue = `axion.${pattern}`;

      await this.channel.assertQueue(queue, {
        durable: true,
      });

      await this.channel.consume(
        queue,
        async (msg) => {
          if (!msg) return;

          try {
            // Десериализация Protobuf сообщения
            const data = JSON.parse(msg.content.toString());

            // Вызов handler
            const result = await handler(data);

            // Отправка ответа (если есть replyTo)
            if (msg.properties.replyTo) {
              this.channel!.sendToQueue(
                msg.properties.replyTo,
                Buffer.from(JSON.stringify(result)),
                {
                  correlationId: msg.properties.correlationId,
                }
              );
            }

            this.channel!.ack(msg);
          } catch (error) {
            console.error(`Error handling message in ${pattern}:`, error);

            // Отправка ошибки
            if (msg.properties.replyTo) {
              this.channel!.sendToQueue(
                msg.properties.replyTo,
                Buffer.from(
                  JSON.stringify({
                    error: true,
                    message:
                      error instanceof Error ? error.message : "Unknown error",
                  })
                ),
                {
                  correlationId: msg.properties.correlationId,
                }
              );
            }

            this.channel!.nack(msg, false, false);
          }
        },
        { noAck: false }
      );

      console.log(`Started consuming from queue: ${queue}`);
    }
  }

  async close() {
    if (this.channel) {
      await this.channel.close();
    }
    if (this.connection) {
      await this.connection.close();
    }
  }
}
```

## LLM Инструкции

**LLM НЕ генерит этот файл** - он создается автоматически из шаблона.

## Checklist

- [ ] Подключение к RabbitMQ работает
- [ ] Handlers регистрируются корректно
- [ ] Сообщения обрабатываются
- [ ] Ошибки обрабатываются
- [ ] Graceful shutdown реализован
